- [Musical Systems](#org06a1cec)
  - [Introduction](#org1c1fa9d)
  - [Musical Systems](#org4722bc4)
  - [Set Classes](#org939a8e3)
  - [Forte Table](#org7e4cdbb)
  - [Class Elements](#orgc78dc30)
  - [Webern Matrices](#org58b0278)



<a id="org06a1cec"></a>

# Musical Systems


<a id="org1c1fa9d"></a>

## Introduction

We provide here the routines to work with new musical systems as described in the paper [Alternative Symmetries and Systems](). But even if one is only interested in working with the standard system, the routines provide some tools for dealing with common music theory elements.

Note that these routines run in [Sage](https://www.sagemath.org/), not straight [Python](https://www.python.org/), as it makes it easier to deal with permutation and groups.

Sage is free and open source, and can be used in any platform. If one wants to use it without having to install it, [Cocalc](https://cocalc.com/) allows you to run it online, but it is necessary to create an account.

The file `MusicalSystem.sage` provides all necessary routines. It provides five classes:

-   `MusicalSystem`: allows you to create new musical systems and manipulate some of its elements.
-   `SetClass`: to deal with set classes in new musical systems.
-   `ForteTable:` to produce Forte tables for new musical systems.
-   `ClassElements:` to see the set of all set classes and their elements of a fixed size in a musical system.
-   `Webern Matrix:` to produce examples of Webern matrices in new systems.

We describe the functionality of each below.


<a id="org4722bc4"></a>

## Musical Systems

We will walk through some of the features with some concrete examples. First we need to load the file:

```sage
load('MusicalSystem.sage')
```

One can create the standard (equal temperament) system by calling `MusicalSystem` with no arguments:

```sage
SMS = MusicalSystem()
SMS
```

    MusicalSystem(rho=(0,1,2,3,4,5,6,7,8,9,10,11), phi=(1,11)(2,10)(3,9)(4,8)(5,7)): Musical System given by rotation (0,1,2,3,4,5,6,7,8,9,10,11) and reflection (1,11)(2,10)(3,9)(4,8)(5,7)

To create a new system, let's first create the symmetric group on integers modulo 12 (or the set {0, 1, 2, 3, &#x2026; , 11}) in Sage:

```sage
S12 = SymmetricGroup(range(12))
```

**IMPORTANT:** Note that Sage, like commonly in group theory, compose permutations from left to right, instead of the usual right to left used for functions in general in all mathematics. So, for Sage, `(sigma * tau)(x)` means `tau(sigma(x))`, and not the usual `sigma(tau(x))`. On the other hand, */I will always refer to composition the usual way*, i.e., from right to left.

Let's also create the standard rotation/transposition and reflection/inversion:

```sage
rho = S12([(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)])
phi = S12([(1, 11), (2, 10), (3, 9), (4, 8), (5, 7)])
```

We can obtain the corresponding rotation and reflection from a system with `.rho` and `.phi`:

```sage
SMS.rho == rho, SMS.phi == phi
```

    (True, True)

Let's now create a new system given by the rotation `(0, 4, 11, 3, 7, 2, 6, 10, 5, 9, 1, 8)` and the usual reflection `phi`:

```sage
rho1 = S12([(0, 4, 11, 3, 7, 2, 6, 10, 5, 9, 1, 8)])
phi1 = phi  # same as the standard system
MS1 = MusicalSystem(rho1, phi1)
MS1
```

    MusicalSystem(rho=(0,4,11,3,7,2,6,10,5,9,1,8), phi=(1,11)(2,10)(3,9)(4,8)(5,7)): Musical System given by rotation (0,4,11,3,7,2,6,10,5,9,1,8) and reflection (1,11)(2,10)(3,9)(4,8)(5,7)

As observed in the paper, every new system can be given by a conjugation of the original dihedral group by some permutation. We can use a permutation to create a new system with `MusicalSystem.from_conj`:

```sage
sigma = S12([(0,1,8,7,6,9), (2,5,3,11,4)])  # some permutation
MS2 = MusicalSystem.from_conj(sigma)
MS2
```

    MusicalSystem(rho=(0,10,4,1,8,5,11,2,3,9,6,7), phi=(1,9)(2,5)(3,8)(4,6)(7,10)): Musical System given by rotation (0,10,4,1,8,5,11,2,3,9,6,7) and reflection (1,9)(2,5)(3,8)(4,6)(7,10)

Let's save the corresponding rotation and reflection as `rho2` and `phi2`:

```sage
rho2, phi2 = MS2.rho, MS2.phi
```

Note that we can get also the *group* of symmetries itself from the system with `.group`:

```sage
H2 = MS2.group
H2
```

    Subgroup generated by [(1,9)(2,5)(3,8)(4,6)(7,10), (0,10,4,1,8,5,11,2,3,9,6,7)] of (Symmetric group of order 12! as a permutation group)

Of course, it is a dihedral group:

```sage
H2.is_isomorphic(DihedralGroup(12))
```

    True

We can measure intervals in any of the systems. Let's see what are the intervals between the pitch classes 3 and 10 in these systems:

```sage
SMS.interval(3, 10), MS1.interval(3, 10), MS2.interval(3, 10)
```

    (7, 4, 5)

Let's check:

```sage
(rho^7)(3) == 10, (rho1^4)(3) == 10, (rho2^5)(3) == 10
```

    (True, True, True)

We can also ask for the interval class:

```sage
SMS.interval_class(3, 10), MS1.interval_class(3, 10), MS2.interval_class(3, 10)
```

    (5, 4, 5)

Of course, we can change the order and obtain the same result:

```sage
SMS.interval_class(10, 3), MS1.interval_class(10, 3), MS2.interval_class(10, 3)
```

    (5, 4, 5)

Given a pitch class set (given as a list), we can ask for the normal form in the corresponding system:

```sage
pc_set = [3, 5, 10, 11]
SMS.normal_form(pc_set), MS1.normal_form(pc_set), MS2.normal_form(pc_set)
```

    ([10, 11, 3, 5], [11, 3, 10, 5], [10, 5, 11, 3])

We can also find what are the symmetries of a pitch class set for each system:

```sage
pc_set = [0, 4, 8]
SMS.symmetries(pc_set)
```

    [(0, 0), (4, 0), (8, 0), (0, 1), (4, 1), (8, 1)]

The output tells us that the pitch class set `[0, 4, 8]` is mapped onto itself by `rho^0 * phi^0` (the identity), `rho^4 * phi^0 = \rho^4`, `rho^8 phi^0 = rho^8`, `rho^0 * phi^1 = \phi`, `rho^4 * phi^1 = rho^4 * phi`, and `rho^8 * phi^1 = rho^8 * phi`. (Note, here I'm writing in the *usual* way, but in computations in Sage `rho` and `phi` have to be switched.)

Let's check if this same set has any symmetries in the other systems:

```sage
MS1.symmetries(pc_set)
```

    [(0, 0), (0, 1)]

So, in the systems `MS1`, only the identity and `phi1` preserve the set.

```sage
MS2.symmetries(pc_set)
```

    [(0, 0), (4, 1)]

In the system `MS2`, only the identity and `rho_2^4 * phi_2` preserve the set.

We can also compute class sums of pitch class sets in any system:

```sage
pc_set = [0, 3, 8, 10]
SMS.class_sum(pc_set), MS1.class_sum(pc_set), MS2.class_sum(pc_set)
```

    (9, 9, 1)

We also have functions to compute symmetries of pitch class sets. To apply the rotation of the system to all pitch classes in the set:

```sage
pc_set = [0, 1, 6]
SMS.vrho(pc_set), MS1.vrho(pc_set), MS2.vrho(pc_set)
```

    ([1, 2, 7], [10, 8, 4], [7, 10, 8])

By default, the result is in *normal form*. Given the option `sort='none'`, it give the result with the outputs ordered according to input:

```sage
pc_set = [0, 1, 6]
SMS.vrho(pc_set, sort='none'), MS1.vrho(pc_set, sort='none'), MS2.vrho(pc_set, sort='none')
```

    ([1, 2, 7], [4, 8, 10], [10, 8, 7])

We can also ask to order in increasing numerical order with the option `sort='sort'`:

```sage
pc_set = [0, 1, 6]
SMS.vrho(pc_set, sort='sort'), MS1.vrho(pc_set, sort='sort'), MS2.vrho(pc_set, sort='sort')
```

    ([1, 2, 7], [4, 8, 10], [7, 8, 10])

Finally, we can sort according to the interval to the pitch class 0 in the system with `sort='rho'`:

```sage
pc_set = [0, 1, 6]
SMS.vrho(pc_set, sort='rho'), MS1.vrho(pc_set, sort='rho'), MS2.vrho(pc_set, sort='rho')
```

    ([1, 2, 7], [4, 10, 8], [10, 8, 7])

We can also compute powers of the rotation with optional argument `power`, for instance, let's take the 4th power:

```sage
pc_set = [0, 1, 6]
SMS.vrho(pc_set, power=4), MS1.vrho(pc_set, power=4), MS2.vrho(pc_set, power=4)
```

    ([4, 5, 10], [1, 11, 7], [4, 8, 2])

We also have the corresponding method `.vphi` for the reflection:

```sage
pc_set = [1, 2, 6]
SMS.vphi(pc_set, sort='none'), MS1.vphi(pc_set, sort='none'), MS2.vphi(pc_set, sort='none')
```

    ([11, 10, 6], [11, 10, 6], [9, 5, 4])

(Remember that `phi_1 = phi`.)

To mix those, we can call `.vmap`. The first argument is the power of the rotation and the second is the power of the reflection, while the third is the pitch class set. Note that the power of the reflection is computed **first** and the power of the rotation **second**. It has the same sorting options as `.vhro` and `.vphi`:

```sage
pc_set = [1, 2, 6]
SMS.vmap(4, 1, pc_set, sort='none'), MS1.vmap(4, 1, pc_set, sort='none'), MS2.vmap(4  , 1, pc_set, sort='none')
```

    ([3, 2, 10], [6, 8, 1], [10, 9, 11])

Finally, given two pitch class sets, we can ask what symmetries of the system maps one to the other:

```sage
pc1 = [0, 3, 5]
pc2 = [2, 4, 7]
MS2.symmetry_maps(pc1, pc2)
```

    [(7, 1)]

This means that `rho2^7 * phi2` (composing the permutations the *usual way* again, from right to left) maps `[0, 3, 5]` to `[2, 4, 7]` in the system `MS2`:

```sage
MS2.vmap(7, 1, pc1)
```

    [2, 7, 4]

(Note that order of the elements in the set does not matter.)


<a id="org939a8e3"></a>

## Set Classes

We can also create set classes in different systems. Still with the systems `SMS`, `MS1`, and `MS2` above, we can create set classes with:

```sage
pc_set = [0, 4, 8]
sc, sc1, sc2 = SetClass(pc_set, MS=SMS), SetClass(pc_set, MS=MS1),  SetClass(pc_set, MS=MS2)
sc, sc1, sc2
```

    (SetClass([0, 4, 8]), with rho = (0,1,2,3,4,5,6,7,8,9,10,11), phi = (1,11)(2,10)(3,9)(4,8)(5,7).  Prime form: (048),
     SetClass([0, 4, 8]), with rho = (0,4,11,3,7,2,6,10,5,9,1,8), phi = (1,11)(2,10)(3,9)(4,8)(5,7).  Prime form: (04e),
     SetClass([0, 4, 8]), with rho = (0,10,4,1,8,5,11,2,3,9,6,7), phi = (1,9)(2,5)(3,8)(4,6)(7,10).  Prime form: (048))

We can also create set classes directly from the system:

```sage
MS1.set_class([2, 5, 11])
```

    SetClass([2, 5, 11]), with rho = (0,4,11,3,7,2,6,10,5,9,1,8), phi = (1,11)(2,10)(3,9)(4,8)(5,7).  Prime form: (036)

We can ask for the number of internal symmetries:

```sage
sc.nsym(), sc1.nsym(), sc2.nsym()
```

    ([3, 3], [1, 1], [1, 1])

The first element is the number of tranpositional symmetries (including the identity) and the second is the number of reflexive symmetries. We can actually see what the symmetries are with `.symmetries`:

```sage
sc.symmetries(), sc1.symmetries(), sc2.symmetries()
```

    ([(0, 0), (4, 0), (8, 0), (0, 1), (4, 1), (8, 1)],
     [(0, 0), (2, 1)],
     [(0, 0), (4, 1)])

We can also ask for the complement of a set class:

```sage
sc2, sc2.complement()
```

    (SetClass([0, 4, 8]), with rho = (0,10,4,1,8,5,11,2,3,9,6,7), phi = (1,9)(2,5)(3,8)(4,6)(7,10).  Prime form: (048),
     SetClass([1, 2, 3, 5, 6, 7, 9, 10, 11]), with rho = (0,10,4,1,8,5,11,2,3,9,6,7), phi = (1,9)(2,5)(3,8)(4,6)(7,10).  Prime form: (0t4185e36))

We can ask for the interval vectors as well:

```sage
sc.interval_vector(), sc1.interval_vector(), sc2.interval_vector()
```

    ([0, 0, 0, 3, 0, 0], [2, 1, 0, 0, 0, 0], [0, 2, 0, 1, 0, 0])

And we can ask for class sums:

```sage
sc1.class_sum()
```

    3

We can ask for all pitch class sets in a set class. For instance:

```sage
sc1.elements()
```

    [(0, 4, 11),
     (1, 8, 0),
     (2, 6, 10),
     (3, 7, 2),
     (4, 11, 3),
     (5, 9, 1),
     (6, 10, 5),
     (7, 2, 6),
     (8, 0, 4),
     (9, 1, 8),
     (10, 5, 9),
     (11, 3, 7)]

Note that the results are in normal form.

As another example, if I want to know all tetrachors that can be mapped to `[10, 4, 5]` in `MS2`, we can do

```sage
SetClass([10, 4, 5], MS=MS2).elements()
```

    [(0, 1, 8),
     (0, 10, 8),
     (1, 8, 2),
     (1, 11, 2),
     (2, 3, 7),
     (2, 6, 7),
     (3, 7, 0),
     (3, 9, 0),
     (4, 1, 11),
     (4, 5, 11),
     (5, 3, 9),
     (5, 11, 9),
     (6, 7, 4),
     (6, 10, 4),
     (7, 0, 1),
     (7, 4, 1),
     (8, 2, 3),
     (8, 5, 3),
     (9, 0, 10),
     (9, 6, 10),
     (10, 4, 5),
     (10, 8, 5),
     (11, 2, 6),
     (11, 9, 6)]

One can also access various internal properties from the set class. For instance, the given pitch class set can be recovered with `.initv`:

```sage
sc1.initv
```

    [0, 4, 8]

It's normal form can be obtained with `.normal_form`:

```sage
sc1.normal_form
```

    [8, 0, 4]

We can recover the corresponding rotation and reflection:

```sage
sc1.rho, sc1.phi
```

    ((0,4,11,3,7,2,6,10,5,9,1,8), (1,11)(2,10)(3,9)(4,8)(5,7))

You can get the musical system as well:

```sage
sc1.MusicalSystem
```

    MusicalSystem(rho=(0,4,11,3,7,2,6,10,5,9,1,8), phi=(1,11)(2,10)(3,9)(4,8)(5,7)): Musical System given by rotation (0,4,11,3,7,2,6,10,5,9,1,8) and reflection (1,11)(2,10)(3,9)(4,8)(5,7)


<a id="org7e4cdbb"></a>

## Forte Table

We can also ask for the *Forte Table* for a system. For instance, here is the Forte Table for trichords and nonachors in the standard system:

```sage
ft = ForteTable(3)
print(ft)
```

    (012)  [ 2 , 1 , 0 , 0 , 0 , 0]   1,  1  [ 8 , 7 , 6 , 6 , 6 , 3]  (012345678)
    (013)  [ 1 , 1 , 1 , 0 , 0 , 0]   1,  0  [ 7 , 7 , 7 , 6 , 6 , 3]  (012345679)
    (014)  [ 1 , 0 , 1 , 1 , 0 , 0]   1,  0  [ 7 , 6 , 7 , 7 , 6 , 3]  (012345689)
    (015)  [ 1 , 0 , 0 , 1 , 1 , 0]   1,  0  [ 7 , 6 , 6 , 7 , 7 , 3]  (012345789)
    (016)  [ 1 , 0 , 0 , 0 , 1 , 1]   1,  0  [ 7 , 6 , 6 , 6 , 7 , 4]  (012346789)
    (024)  [ 0 , 2 , 0 , 1 , 0 , 0]   1,  1  [ 6 , 8 , 6 , 7 , 6 , 3]  (01234568t)
    (025)  [ 0 , 1 , 1 , 0 , 1 , 0]   1,  0  [ 6 , 7 , 7 , 6 , 7 , 3]  (01234578t)
    (026)  [ 0 , 1 , 0 , 1 , 0 , 1]   1,  0  [ 6 , 7 , 6 , 7 , 6 , 4]  (01234678t)
    (027)  [ 0 , 1 , 0 , 0 , 2 , 0]   1,  1  [ 6 , 7 , 6 , 6 , 8 , 3]  (01235678t)
    (036)  [ 0 , 0 , 2 , 0 , 0 , 1]   1,  1  [ 6 , 6 , 8 , 6 , 6 , 4]  (01234679t)
    (037)  [ 0 , 0 , 1 , 1 , 1 , 0]   1,  0  [ 6 , 6 , 7 , 7 , 7 , 3]  (01235679t)
    (048)  [ 0 , 0 , 0 , 3 , 0 , 0]   3,  3  [ 6 , 6 , 6 , 9 , 6 , 3]  (01245689t)

The first and last column have the set classes, the second and second to last have interval vectors, and the two middle columns have the number of transpositional and inversive symmetries, respectively. Note that we do not give the traditional names associated to the rows.

Note that we can also create Forte Tables directly from a system. For instance, the table above could have been created with `SMS.forte_table(3)`.

Let's see it for a different system, say `MS2`, now with tetrachords and octachords:

```sage
ft2 = MS2.forte_table(4)
print(ft2)
```

    (0153)  [ 0 , 1 , 2 , 1 , 2 , 0]   1,  1  [ 4 , 5 , 6 , 5 , 6 , 2]  (0t185236)
    (0182)  [ 1 , 0 , 2 , 2 , 1 , 0]   1,  1  [ 5 , 4 , 6 , 6 , 5 , 2]  (0t185e39)
    (01e9)  [ 0 , 0 , 4 , 0 , 0 , 2]   4,  4  [ 4 , 4 , 8 , 4 , 4 , 4]  (0t18e296)
    (0412)  [ 1 , 1 , 1 , 1 , 2 , 0]   1,  0  [ 5 , 5 , 5 , 5 , 6 , 2]  (0t485e29)
    (0415)  [ 1 , 2 , 2 , 0 , 1 , 0]   1,  1  [ 5 , 6 , 6 , 4 , 5 , 2]  (04185e29)
    (041e)  [ 1 , 1 , 2 , 1 , 0 , 1]   1,  0  [ 5 , 5 , 6 , 5 , 4 , 3]  (0t185e29)
    (0452)  [ 0 , 2 , 1 , 0 , 3 , 0]   1,  1  [ 4 , 6 , 5 , 4 , 7 , 2]  (0t415236)
    (0453)  [ 0 , 1 , 2 , 1 , 1 , 1]   1,  0  [ 4 , 5 , 6 , 5 , 5 , 3]  (0t485236)
    (0482)  [ 0 , 2 , 1 , 1 , 2 , 0]   1,  0  [ 4 , 6 , 5 , 5 , 6 , 2]  (0t415e36)
    (0483)  [ 0 , 2 , 0 , 3 , 0 , 1]   1,  1  [ 4 , 6 , 4 , 7 , 4 , 3]  (0t485e36)
    (048e)  [ 0 , 3 , 0 , 2 , 0 , 1]   1,  1  [ 4 , 7 , 4 , 6 , 4 , 3]  (0t418e36)
    (04e3)  [ 0 , 2 , 0 , 2 , 0 , 2]   2,  2  [ 4 , 6 , 4 , 6 , 4 , 4]  (0t48e236)
    (0t12)  [ 1 , 1 , 1 , 1 , 1 , 1]   1,  0  [ 5 , 5 , 5 , 5 , 5 , 3]  (0t415e29)
    (0t15)  [ 1 , 2 , 1 , 1 , 1 , 0]   1,  0  [ 5 , 6 , 5 , 5 , 5 , 2]  (0t418529)
    (0t18)  [ 2 , 1 , 2 , 1 , 0 , 0]   1,  1  [ 6 , 5 , 6 , 5 , 4 , 2]  (0t4185e9)
    (0t1e)  [ 1 , 1 , 2 , 0 , 1 , 1]   1,  0  [ 5 , 5 , 6 , 4 , 5 , 3]  (0t418e29)
    (0t41)  [ 3 , 2 , 1 , 0 , 0 , 0]   1,  1  [ 7 , 6 , 5 , 4 , 4 , 2]  (0t4185e2)
    (0t42)  [ 2 , 1 , 0 , 0 , 2 , 1]   1,  1  [ 6 , 5 , 4 , 4 , 6 , 3]  (0t415e23)
    (0t45)  [ 2 , 1 , 1 , 1 , 1 , 0]   1,  0  [ 6 , 5 , 5 , 5 , 5 , 2]  (0t418523)
    (0t48)  [ 2 , 2 , 1 , 1 , 0 , 0]   1,  0  [ 6 , 6 , 5 , 5 , 4 , 2]  (0t4185e3)
    (0t4e)  [ 2 , 1 , 0 , 1 , 1 , 1]   1,  0  [ 6 , 5 , 4 , 5 , 5 , 3]  (0t418e23)
    (0t52)  [ 1 , 1 , 0 , 1 , 2 , 1]   1,  0  [ 5 , 5 , 4 , 5 , 6 , 3]  (0t415239)
    (0t53)  [ 1 , 0 , 1 , 2 , 2 , 0]   1,  1  [ 5 , 4 , 5 , 6 , 6 , 2]  (0t485239)
    (0t5e)  [ 2 , 0 , 0 , 1 , 2 , 1]   1,  1  [ 6 , 4 , 4 , 5 , 6 , 3]  (0t418239)
    (0t82)  [ 1 , 0 , 2 , 1 , 1 , 1]   1,  0  [ 5 , 4 , 6 , 5 , 5 , 3]  (0t415e39)
    (0t83)  [ 1 , 0 , 1 , 3 , 1 , 0]   1,  0  [ 5 , 4 , 5 , 7 , 5 , 2]  (0t485e39)
    (0t85)  [ 2 , 0 , 1 , 2 , 1 , 0]   1,  1  [ 6 , 4 , 5 , 6 , 5 , 2]  (0t418539)
    (0t8e)  [ 1 , 1 , 1 , 1 , 1 , 1]   1,  0  [ 5 , 5 , 5 , 5 , 5 , 3]  (0t418e39)
    (0te2)  [ 2 , 0 , 0 , 0 , 2 , 2]   2,  2  [ 6 , 4 , 4 , 4 , 6 , 4]  (0t41e239)

We can also ask for the output in LaTeX:

```sage
print(ft2.latex())
```

    \begin{tabular}{llrll}
      \multicolumn{2}{c}{\textbf{Tetrachords}} &  & \multicolumn{2}{c}{\textbf{Octachords}} \\
      \midrule
      $(0153)$ & $012120$ & $1$, $1$ & $456562$ & $(0t185236)$\\
      $(0182)$ & $102210$ & $1$, $1$ & $546652$ & $(0t185e39)$\\
      $(01e9)$ & $004002$ & $4$, $4$ & $448444$ & $(0t18e296)$\\
      $(0412)$ & $111120$ & $1$, $0$ & $555562$ & $(0t485e29)$\\
      $(0415)$ & $122010$ & $1$, $1$ & $566452$ & $(04185e29)$\\
      $(041e)$ & $112101$ & $1$, $0$ & $556543$ & $(0t185e29)$\\
      $(0452)$ & $021030$ & $1$, $1$ & $465472$ & $(0t415236)$\\
      $(0453)$ & $012111$ & $1$, $0$ & $456553$ & $(0t485236)$\\
      $(0482)$ & $021120$ & $1$, $0$ & $465562$ & $(0t415e36)$\\
      $(0483)$ & $020301$ & $1$, $1$ & $464743$ & $(0t485e36)$\\
      $(048e)$ & $030201$ & $1$, $1$ & $474643$ & $(0t418e36)$\\
      $(04e3)$ & $020202$ & $2$, $2$ & $464644$ & $(0t48e236)$\\
      $(0t12)$ & $111111$ & $1$, $0$ & $555553$ & $(0t415e29)$\\
      $(0t15)$ & $121110$ & $1$, $0$ & $565552$ & $(0t418529)$\\
      $(0t18)$ & $212100$ & $1$, $1$ & $656542$ & $(0t4185e9)$\\
      $(0t1e)$ & $112011$ & $1$, $0$ & $556453$ & $(0t418e29)$\\
      $(0t41)$ & $321000$ & $1$, $1$ & $765442$ & $(0t4185e2)$\\
      $(0t42)$ & $210021$ & $1$, $1$ & $654463$ & $(0t415e23)$\\
      $(0t45)$ & $211110$ & $1$, $0$ & $655552$ & $(0t418523)$\\
      $(0t48)$ & $221100$ & $1$, $0$ & $665542$ & $(0t4185e3)$\\
      $(0t4e)$ & $210111$ & $1$, $0$ & $654553$ & $(0t418e23)$\\
      $(0t52)$ & $110121$ & $1$, $0$ & $554563$ & $(0t415239)$\\
      $(0t53)$ & $101220$ & $1$, $1$ & $545662$ & $(0t485239)$\\
      $(0t5e)$ & $200121$ & $1$, $1$ & $644563$ & $(0t418239)$\\
      $(0t82)$ & $102111$ & $1$, $0$ & $546553$ & $(0t415e39)$\\
      $(0t83)$ & $101310$ & $1$, $0$ & $545752$ & $(0t485e39)$\\
      $(0t85)$ & $201210$ & $1$, $1$ & $645652$ & $(0t418539)$\\
      $(0t8e)$ & $111111$ & $1$, $0$ & $555553$ & $(0t418e39)$\\
      $(0te2)$ & $200022$ & $2$, $2$ & $644464$ & $(0t41e239)$
    \end{tabular}


<a id="orgc78dc30"></a>

## Class Elements

We can also print all set classes while listing every element in each set class. (Long output!)

For instance, let's look at out set classes of size four and their elements in the standard system:

```sage
ce = ClassElements(4)
print(ce)
```

The output is too long to be displayed here, but it gives a series of columns, with the prime form of the set class on top, and the elements in the class below it.

We can also break the result in smaller number of columns:

```sage
ce.print_col(ncol=6)
```

Again, the output is too long, but is it more suitable for printing. In the case above, it prints by breaking the output in sets of six columns.

We can produce a class in other system by specifying the system with the optional argument `MS`, as in, for instance, `ClassElements(3, MS=MS1)`. But, this can also be created from the system itself using `.class_ements`:

```sage
ce1 = MS1.class_elements(3)
```

You can access the internal data with `.matrix`. For instance, the following takes the 4th column of the `ce1`, which contains the elements in some set class, with the prime form on top:

```sage
(ce1.matrix)[3]
```

    [(0, 11, 7),
     (1, 0, 11),
     (2, 10, 9),
     (3, 2, 10),
     (4, 3, 2),
     (5, 1, 0),
     (6, 5, 1),
     (7, 6, 5),
     (8, 4, 3),
     (9, 8, 4),
     (10, 9, 8),
     (11, 7, 6)]

As usual, the results are in normal form. Also, we can see now many different set classes of size 3 we have in the system `MS1`:

```sage
len(ce1.matrix)
```

    12

There are 12 different set classes.

We can also see what is the variation of number of elements in the set classes:

```sage
min(len(sc) for sc in ce1.matrix), max(len(sc) for sc in ce1.matrix)
```

    (4, 24)

The number of elements varies from 4 to 24.


<a id="org58b0278"></a>

## Webern Matrices

We can also construct Webern matrices. To see the original matrix, we can do:

```sage
wm = WebernMatrix()
print(wm)
```

        |   0  11   3   4   8   7   9   5   6   1   2  10  |
    ----|--------------------------------------------------|----
     0  |   0  11   3   4   8   7   9   5   6   1   2  10  |  10
     1  |   1   0   4   5   9   8  10   6   7   2   3  11  |  11
     9  |   9   8   0   1   5   4   6   2   3  10  11   7  |   7
     8  |   8   7  11   0   4   3   5   1   2   9  10   6  |   6
     4  |   4   3   7   8   0  11   1   9  10   5   6   2  |   2
     5  |   5   4   8   9   1   0   2  10  11   6   7   3  |   3
     3  |   3   2   6   7  11  10   0   8   9   4   5   1  |   1
     7  |   7   6  10  11   3   2   4   0   1   8   9   5  |   5
     6  |   6   5   9  10   2   1   3  11   0   7   8   4  |   4
    11  |  11  10   2   3   7   6   8   4   5   0   1   9  |   9
    10  |  10   9   1   2   6   5   7   3   4  11   0   8  |   8
     2  |   2   1   5   6  10   9  11   7   8   3   4   0  |   0
    ----|--------------------------------------------------|----
        |   2   1   5   6  10   9  11   7   8   3   4   0  |

The numbers on the left are the powers of the rotation that take the first row into the corresponding row. The numbers on top are the powers of the rotation that when composed with the reflection take the first row into the corresponding *column*. The right numbers and bottom numbers are similar, but with the *retrogrades*. See the Section 3 of [Alternative Symmetries and Systems](https://web.math.utk.edu/~finotti/papers/mussys.pdf) for more details.

We can also get the whole matrix (without the labels) with `.matrix`:

```sage
wm.matrix
```

    [(0, 11, 3, 4, 8, 7, 9, 5, 6, 1, 2, 10),
     [1, 0, 4, 5, 9, 8, 10, 6, 7, 2, 3, 11],
     [9, 8, 0, 1, 5, 4, 6, 2, 3, 10, 11, 7],
     [8, 7, 11, 0, 4, 3, 5, 1, 2, 9, 10, 6],
     [4, 3, 7, 8, 0, 11, 1, 9, 10, 5, 6, 2],
     [5, 4, 8, 9, 1, 0, 2, 10, 11, 6, 7, 3],
     [3, 2, 6, 7, 11, 10, 0, 8, 9, 4, 5, 1],
     [7, 6, 10, 11, 3, 2, 4, 0, 1, 8, 9, 5],
     [6, 5, 9, 10, 2, 1, 3, 11, 0, 7, 8, 4],
     [11, 10, 2, 3, 7, 6, 8, 4, 5, 0, 1, 9],
     [10, 9, 1, 2, 6, 5, 7, 3, 4, 11, 0, 8],
     [2, 1, 5, 6, 10, 9, 11, 7, 8, 3, 4, 0]]

If you want just the labels, we can get them with `.left`, `.top`, `.right`, `.bottom`:

```sage
wm.left, wm.top, wm.right, wm.bottom
```

    ([0, 1, 9, 8, 4, 5, 3, 7, 6, 11, 10, 2],
     [0, 11, 3, 4, 8, 7, 9, 5, 6, 1, 2, 10],
     [10, 11, 7, 6, 2, 3, 1, 5, 4, 9, 8, 0],
     [2, 1, 5, 6, 10, 9, 11, 7, 8, 3, 4, 0])

Or, we can extract rows and columns (indexing starting at 0, as usual in Python/Sage):

```sage
wm.row(3), wm.column(8)
```

    ([8, 7, 11, 0, 4, 3, 5, 1, 2, 9, 10, 6],
     [6, 7, 3, 2, 10, 11, 9, 1, 0, 5, 4, 8])

We can also print it with LaTeX:

```sage
print(wm.latex())
```

    \begin{tabular}{c|cccccccccccc|c}
         &  $\phi$ &  $\rho^{11} \phi$ &  $\rho^{3} \phi$ &  $\rho^{4} \phi$ &  $\rho^{8} \phi$ &  $\rho^{7} \phi$ &  $\rho^{9} \phi$ &  $\rho^{5} \phi$ &  $\rho^{6} \phi$ &  $\rho \phi$ &  $\rho^{2} \phi$ &  $\rho^{10} \phi$ &    \\
      \hline
      $1$ & $0$ & $11$ & $3$ & $4$ & $8$ & $7$ & $9$ & $5$ & $6$ & $1$ & $2$ & $10$ & $\rho^{10}$ \\
      $\rho$ & $1$ & $0$ & $4$ & $5$ & $9$ & $8$ & $10$ & $6$ & $7$ & $2$ & $3$ & $11$ & $\rho^{11}$ \\
      $\rho^{9}$ & $9$ & $8$ & $0$ & $1$ & $5$ & $4$ & $6$ & $2$ & $3$ & $10$ & $11$ & $7$ & $\rho^{7}$ \\
      $\rho^{8}$ & $8$ & $7$ & $11$ & $0$ & $4$ & $3$ & $5$ & $1$ & $2$ & $9$ & $10$ & $6$ & $\rho^{6}$ \\
      $\rho^{4}$ & $4$ & $3$ & $7$ & $8$ & $0$ & $11$ & $1$ & $9$ & $10$ & $5$ & $6$ & $2$ & $\rho^{2}$ \\
      $\rho^{5}$ & $5$ & $4$ & $8$ & $9$ & $1$ & $0$ & $2$ & $10$ & $11$ & $6$ & $7$ & $3$ & $\rho^{3}$ \\
      $\rho^{3}$ & $3$ & $2$ & $6$ & $7$ & $11$ & $10$ & $0$ & $8$ & $9$ & $4$ & $5$ & $1$ & $\rho$ \\
      $\rho^{7}$ & $7$ & $6$ & $10$ & $11$ & $3$ & $2$ & $4$ & $0$ & $1$ & $8$ & $9$ & $5$ & $\rho^{5}$ \\
      $\rho^{6}$ & $6$ & $5$ & $9$ & $10$ & $2$ & $1$ & $3$ & $11$ & $0$ & $7$ & $8$ & $4$ & $\rho^{4}$ \\
      $\rho^{11}$ & $11$ & $10$ & $2$ & $3$ & $7$ & $6$ & $8$ & $4$ & $5$ & $0$ & $1$ & $9$ & $\rho^{9}$ \\
      $\rho^{10}$ & $10$ & $9$ & $1$ & $2$ & $6$ & $5$ & $7$ & $3$ & $4$ & $11$ & $0$ & $8$ & $\rho^{8}$ \\
      $\rho^{2}$ & $2$ & $1$ & $5$ & $6$ & $10$ & $9$ & $11$ & $7$ & $8$ & $3$ & $4$ & $0$ & $1$ \\
      \hline
         &  $\rho^{2} \phi$ &  $\rho \phi$ &  $\rho^{5} \phi$ &  $\rho^{6} \phi$ &  $\rho^{10} \phi$ &  $\rho^{9} \phi$ &  $\rho^{11} \phi$ &  $\rho^{7} \phi$ &  $\rho^{8} \phi$ &  $\rho^{3} \phi$ &  $\rho^{4} \phi$ &  $\phi$ &
    \end{tabular}

We can also create new Webern matrices using other systems, but first we need a first row. Let's use `MS2`. We can get possible first rows with:

```sage
first_webern_rows = MS2.find_all_first_webern_rows()
```

The complete output is too long:

```sage
len(first_webern_rows)
```

    204

So, lets look at only the first 20 possible rows:

```sage
first_webern_rows[:20]
```

    [[(0, 1, 3), (2, 7, 8), (4, 5, 6), (9, 10, 11), [3, 3]],
     [(0, 1, 3), (2, 7, 8), (4, 5, 9), (6, 10, 11), [3, 3]],
     [(0, 1, 3), (2, 7, 8), (5, 6, 10), (4, 9, 11), [3, 3]],
     [(0, 1, 3), (5, 6, 10), (4, 9, 11), (2, 7, 8), [1, 1]],
     [(0, 2, 8), (1, 3, 7), (4, 5, 6), (9, 10, 11), [3, 3]],
     [(0, 2, 8), (1, 3, 7), (4, 5, 9), (6, 10, 11), [3, 3]],
     [(0, 2, 8), (1, 3, 7), (5, 6, 10), (4, 9, 11), [3, 3]],
     [(0, 2, 8), (4, 5, 9), (1, 3, 7), (6, 10, 11), [1, 1]],
     [(1, 6, 11), (2, 4, 7), (3, 5, 10), (0, 8, 9), [3, 3]],
     [(1, 6, 11), (2, 4, 7), (8, 9, 10), (0, 3, 5), [3, 3]],
     [(1, 6, 11), (3, 5, 10), (2, 4, 7), (0, 8, 9), [1, 1]],
     [(3, 5, 10), (0, 8, 9), (1, 7, 11), (2, 4, 6), [3, 3]],
     [(3, 8, 10), (0, 5, 9), (1, 6, 11), (2, 4, 7), [3, 3]],
     [(3, 8, 10), (0, 5, 9), (1, 7, 11), (2, 4, 6), [3, 3]],
     [(3, 8, 10), (0, 5, 9), (4, 7, 11), (1, 2, 6), [3, 3]],
     [(3, 8, 10), (1, 7, 11), (0, 5, 9), (2, 4, 6), [1, 1]],
     [(4, 5, 6), (0, 1, 2), (3, 7, 8), (9, 10, 11), [1, 1]],
     [(4, 5, 6), (9, 10, 11), (0, 1, 2), (3, 7, 8), [3, 3]],
     [(4, 5, 9), (6, 10, 11), (0, 1, 2), (3, 7, 8), [3, 3]],
     [(4, 7, 11), (1, 2, 6), (3, 5, 10), (0, 8, 9), [3, 3]]]

The result is divided in four trichords, all in the same class, and the number of symmetries of the corresponding class.

For instance, let's choose the thirteenth row:

```sage
first_webern_rows[12]
```

    [(3, 8, 10), (0, 5, 9), (1, 6, 11), (2, 4, 7), [3, 3]]

We can see that the trichords are indeed related by symmetry, by asking what are the symmetries that map one to another. For instance:

```sage
wrow = first_webern_rows[12]
t1, t2, t3, t4, _ = wrow
MS2.symmetry_maps(t1, t2), MS2.symmetry_maps(t2, t4)
```

    ([(1, 1)], [(2, 0)])

This means that `rho_2 * phi2` maps `[3, 8, 10]` to `[0, 5, 9]` and `rho2^2` maps `[0, 5, 9]` to `[2, 4, 7]`.

We can see if this first row has hexachords that are also related by symmetries:

```sage
MS2.symmetry_maps(t1 + t2, t3 + t4)
```

    [(11, 1), (7, 1), (3, 1), (2, 0), (10, 0), (6, 0)]

Indeed, the hexachords are related by three rotations (transpositions) and three reflection (inversions)!

So, now we can use this first row to create a Webern matrix in this system. We can scramble the order of the trichors, and the other of the pitch classes inside each trichord. Here we create the matrix using the system itself:

```sage
first_row = [0, 9, 5, 7, 4, 2, 1, 6, 11, 10, 3, 8]
wm2 = MS2.webern_matrix(first_row)
print(wm2)
```

        |   0   9   5  11   2   7   3  10   6   1   8   4  |
    ----|--------------------------------------------------|----
     0  |   0   9   5   7   4   2   1   6  11  10   3   8  |   4
     3  |   1   0   3   4   5   6  11  10   9   8   7   2  |   7
     7  |   2   8   0  11   9   4   6   5  10   3   1   7  |  11
     1  |  10   6  11   0   1   3   8   7   2   4   9   5  |   5
    10  |   6   2   1   9   0   5  10   3   8   7  11   4  |   2
     5  |   5   4   6   8   2   0   3   1   7  11  10   9  |   9
     9  |   9  11   4   3   7   8   0   2   1   6   5  10  |   1
     2  |   4   7   2  10   8   9   5   0   3   1   6  11  |   6
     6  |  11   1   7   5   3  10   9   8   0   2   4   6  |  10
    11  |   7   3   8   6  10  11   4   9   5   0   2   1  |   3
     4  |   8  10   9   1  11   7   2   4   6   5   0   3  |   8
     8  |   3   5  10   2   6   1   7  11   4   9   8   0  |   0
    ----|--------------------------------------------------|----
        |   8   5   1   7  10   3  11   6   2   9   4   0  |

(We could also have used `wm2 = WebernMatrix(first_row, MS=MS2)` for the same result.)

To print in LaTeX, we can also give the names to the maps. In this case, we can use `rho2` and `phi2`:

```sage
print(wm2.latex(srho='\\rho_2', sphi='\\phi_2'))
```

    \begin{tabular}{c|cccccccccccc|c}
         &  $\phi_2$ &  $\rho_2^{9} \phi_2$ &  $\rho_2^{5} \phi_2$ &  $\rho_2^{11} \phi_2$ &  $\rho_2^{2} \phi_2$ &  $\rho_2^{7} \phi_2$ &  $\rho_2^{3} \phi_2$ &  $\rho_2^{10} \phi_2$ &  $\rho_2^{6} \phi_2$ &  $\rho_2 \phi_2$ &  $\rho_2^{8} \phi_2$ &  $\rho_2^{4} \phi_2$ &    \\
      \hline
      $1$ & $0$ & $9$ & $5$ & $7$ & $4$ & $2$ & $1$ & $6$ & $11$ & $10$ & $3$ & $8$ & $\rho_2^{4}$ \\
      $\rho_2^{3}$ & $1$ & $0$ & $3$ & $4$ & $5$ & $6$ & $11$ & $10$ & $9$ & $8$ & $7$ & $2$ & $\rho_2^{7}$ \\
      $\rho_2^{7}$ & $2$ & $8$ & $0$ & $11$ & $9$ & $4$ & $6$ & $5$ & $10$ & $3$ & $1$ & $7$ & $\rho_2^{11}$ \\
      $\rho_2$ & $10$ & $6$ & $11$ & $0$ & $1$ & $3$ & $8$ & $7$ & $2$ & $4$ & $9$ & $5$ & $\rho_2^{5}$ \\
      $\rho_2^{10}$ & $6$ & $2$ & $1$ & $9$ & $0$ & $5$ & $10$ & $3$ & $8$ & $7$ & $11$ & $4$ & $\rho_2^{2}$ \\
      $\rho_2^{5}$ & $5$ & $4$ & $6$ & $8$ & $2$ & $0$ & $3$ & $1$ & $7$ & $11$ & $10$ & $9$ & $\rho_2^{9}$ \\
      $\rho_2^{9}$ & $9$ & $11$ & $4$ & $3$ & $7$ & $8$ & $0$ & $2$ & $1$ & $6$ & $5$ & $10$ & $\rho_2$ \\
      $\rho_2^{2}$ & $4$ & $7$ & $2$ & $10$ & $8$ & $9$ & $5$ & $0$ & $3$ & $1$ & $6$ & $11$ & $\rho_2^{6}$ \\
      $\rho_2^{6}$ & $11$ & $1$ & $7$ & $5$ & $3$ & $10$ & $9$ & $8$ & $0$ & $2$ & $4$ & $6$ & $\rho_2^{10}$ \\
      $\rho_2^{11}$ & $7$ & $3$ & $8$ & $6$ & $10$ & $11$ & $4$ & $9$ & $5$ & $0$ & $2$ & $1$ & $\rho_2^{3}$ \\
      $\rho_2^{4}$ & $8$ & $10$ & $9$ & $1$ & $11$ & $7$ & $2$ & $4$ & $6$ & $5$ & $0$ & $3$ & $\rho_2^{8}$ \\
      $\rho_2^{8}$ & $3$ & $5$ & $10$ & $2$ & $6$ & $1$ & $7$ & $11$ & $4$ & $9$ & $8$ & $0$ & $1$ \\
      \hline
         &  $\rho_2^{8} \phi_2$ &  $\rho_2^{5} \phi_2$ &  $\rho_2 \phi_2$ &  $\rho_2^{7} \phi_2$ &  $\rho_2^{10} \phi_2$ &  $\rho_2^{3} \phi_2$ &  $\rho_2^{11} \phi_2$ &  $\rho_2^{6} \phi_2$ &  $\rho_2^{2} \phi_2$ &  $\rho_2^{9} \phi_2$ &  $\rho_2^{4} \phi_2$ &  $\phi_2$ &
    \end{tabular}

Note that we need the double `\` for the LaTeX names, as in `'\\rho_2`.
